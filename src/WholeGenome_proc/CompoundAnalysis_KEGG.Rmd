---
title: "Summary of Food Associated Compounds - KEGG/Whole Genomes"
date: "`r Sys.Date()`"
params:
  node_file: "default.csv"
---

```{css, echo=FALSE}
h1, h2, h3, h4 {
  text-align: center;
}
```

```{r, setup, echo = F}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, eval = T, echo = F, 
                      fig.align = "center")
options(scipen = 999)
```

```{r}
# load necessary packages 
# Set CRAN mirror for non-interactive installation
options(repos = c(CRAN = "https://cloud.r-project.org"))

packages <- c("dplyr", "ggplot2", "readr", "cowplot", "thematic", "tidyr",
              "tibble", "plotly", "rmarkdown")

for (package in packages) {
  if (!require(package, character.only = TRUE)) {
    install.packages(package)
    library(package, character.only = TRUE)
  }
}
```

```{r}
# get data 
hmdb <- read_csv("../../Data/hmdb.csv")
meta <- read_csv(params$node_file)

# rename hmdb column
colnames(hmdb)[1] <- "c_id"

# clean meta 
colnames(meta)[1] <- "c_id"
meta_clean <- meta %>% 
  filter(origin != 'microbe' & origin != 'none') %>% 
  mutate(assoc_food = gsub("\\[|\\]|'| ", "", assoc_food)) %>%  # remove [], ', and spaces
  separate_rows(assoc_food, sep = ",")  # split into multiple rows
```

Using KEGG, whole genomes of organisms who can be eaten (e.g., plant and animal products) can be used to predict compounds that may have been present in the food at the time of consumption. While this is a general approach it can cover all basis and is not dependent on the preparation of the food (e.g., canned, frozen) or the quality of the food (e.g., ripe).

```{r}
# pi chart of all compounds 
meta_clean %>% 
  group_by(assoc_food) %>% 
  count(assoc_food) %>% 
  ggplot(aes(x = "",y = n, fill = assoc_food)) + 
    geom_bar(stat="identity", width=1) +
    coord_polar("y", start=0) +
    geom_text(aes(label = n),
              position = position_stack(vjust = 0.5)) +
    theme_void() +
    theme(legend.position = "bottom", 
          plot.title = element_text(hjust = 0.5), 
          legend.title = element_blank()) +
    ggtitle("Total Number of Compounds Per\nFood Item")
```

## Detailed Results {.tabset}

### Food Similarity

```{r}
# Summarize compounds and their group status
compound_summary <- meta_clean %>%
  group_by(c_id) %>%
  summarise(
    groups = list(unique(assoc_food)),
    groups_count = n_distinct(assoc_food),
    .groups = "drop"
  ) %>%
  mutate(
    status = ifelse(groups_count == 1, "unique", "shared")
  )

# Count shared compounds (optional, if needed)
shared_count <- compound_summary %>%
  filter(status == "shared") %>%
  summarise(shared_count = n())

# Count unique compounds for each group
compound_summary %>%
  filter(status == "unique") %>%
  unnest(groups) %>%  # Expand the group list
  count(groups, name = "unique_count") -> unique_compounds 

# plot unique compounds and summary stats 
  ggplot(unique_compounds, aes(x = reorder(groups, unique_count), y = unique_count)) + 
    geom_bar(stat = "identity") + 
    labs(x = "Food Item", 
         y = "Number of Compounds Unique to Food Item") + 
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + 
    annotate("text", 
             x = 1, 
             y = max(unique_compounds$unique_count) - median(unique_compounds$unique_count) , 
             label = paste0("Numer of Shared Compounds: ", shared_count$shared_count,
                            "\n\nThe Following Statistics are on the \nNumber of Unique Compounds",
                            "\nMean \u00B1 SD: ", round(mean(unique_compounds$unique_count), 2), 
                                "\u00B1", round(sd(unique_compounds$unique_count), 2), 
                            "\nMedian: ", round(median(unique_compounds$unique_count), 2), 
                            "\nRange: ", round(range(unique_compounds$unique_count)[1], 2), "-", 
                                round(range(unique_compounds$unique_count)[2], 2)
                            )
             )
```

### Taxonomic Classification of Compounds 

Points are colored by the number of compounds found in that taxonomic classification. 

```{r}
meta_clean %>% 
  select(assoc_food, c_id) %>% 
  group_by(assoc_food) %>% 
  distinct() %>% 
  left_join(hmdb, by = "c_id", 
            relationship = "many-to-many") -> joined

joined %>% 
  count(assoc_food, taxonomy_super_class) %>% 
  ggplot(aes(y=taxonomy_super_class, x=assoc_food)) +
    geom_point(aes(color = n), size = 4) + 
    scale_color_gradient(low = "yellow", high = "purple4") +
    theme_bw() + 
    theme(legend.title = element_blank(), 
          axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + 
    xlab("name") + 
    ylab("Taxonomy Super Class ")
```

```{r, fig.height=length(unique(joined$taxonomy_class))/5}
joined %>% 
  count(assoc_food, taxonomy_class) %>% 
  ggplot(aes(y=taxonomy_class, x=assoc_food)) +
    geom_point(aes(color = n), size = 4) + 
    scale_color_gradient(low = "yellow", high = "purple4") +
    theme_bw() + 
    theme(legend.title = element_blank(), 
          axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + 
    xlab("name") + 
    ylab("Taxonomy Class ")
```

## Diet Meta-Analysis 

<center>
Identifying similarity and dissimilarity between food items.
```{r}
# must remove NAs for this portion 
meta_clean <- meta_clean %>% na.omit()

# make a function to calculte jaccard similarity between food items
jaccard_similarity <- function(food1, food2){ 
  intersection <- length(intersect(food1, food2))
  union <- length(food1) + length(food2) - intersection
  return(intersection/union)
}

# get list of food items
food_items <- unique(meta_clean$assoc_food)

# for each pair of food items calculate jaccard similarity and create a list 
jaccard_score <- c()
for(food1 in food_items){
  for (food2 in food_items) {
    
    # get list of unique compounds for food1
    food1_df <- meta_clean %>%
      select(assoc_food, c_id) %>%
      filter(assoc_food == food1) 
    food1_compounds <- unique(food1_df$c_id)
      
    # get list of unique compounds for food2
    food2_df <- meta_clean %>%
      select(assoc_food, c_id) %>%
      filter(assoc_food == food2)
    food2_compounds <- unique(food2_df$c_id)
    
    # calculate score and add to list 
    score <- jaccard_similarity(food1_compounds, food2_compounds)
    jaccard_score <- c(jaccard_score, c(score))
  }
}

# create matrix 
jaccard_matrix <- matrix(
  jaccard_score, 
  nrow = length(food_items), 
  ncol = length(food_items), 
)
colnames(jaccard_matrix) <- food_items
rownames(jaccard_matrix) <- food_items

# create a long format for matrix
jaccard_long <- as.data.frame(jaccard_matrix) %>% 
  rownames_to_column(var = "Row") %>% 
  pivot_longer(cols = -Row, names_to = "Column", values_to = "Value")

# visualize matrix
ggplot(jaccard_long, aes(x = Column, y = Row, fill = Value)) +
  geom_tile() + 
  scale_fill_gradient(low = "lightblue", high = "darkblue") + 
  labs(title = "Jaccard Matrix Heatmap", x = " ", y = " ", fill = "Simiarity Score") +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1), 
        plot.title = element_text(hjust = 0.5)) -> p

plotly::ggplotly(p)
```





